---
title: MySQL——事务处理
date: 2020-02-06
author: liuwei
location: Zhengzhou
---

<p>&emsp;&emsp;为什么要使用事务？在进行数据处理的时候通常会遇到一次要处理多条sql语句，操作几张表，这时可能会遇到某个表添加失败，为了保证这一次操作的一致性，就要用到事务。如果失败则全部sql都会失效。</p>

### 事务处理步骤：

1. 开启事务；
```sql
start transaction;
# 或者使用
begin;
```
2. 进行数据处理；
3. 提交事务；
```sql
# 在进行完全部的数据处理后提交事务
commit;
```
4. 回滚事务。
```sql
# 如果在数据处理中出现了问题，就进行回滚操作
rollback;
```
* 可以使用程序语言（或框架）支持的事务处理

### 事务隔离
<p>&emsp;&emsp;在多个事务同时执行时会遇到事务之间处理同一处数据的情况，这时会出现有脏读，不可重复读，幻读等情况，对应有不同的事务隔离级别，分别是：读未提交（read-uncommitted），读提交（read-committed），可重复读（repeatable-read），串行化（serializable）</p>

1. **脏读** 指一个事务在没有提交时，其他事务就读到了这个事务修改的数据，当事务隔离级别为“读未提交”时会出现脏读，设置为“读提交”或更高级别可以避免脏读。
2. **不可重复读** 指一个事务a第一次读取数据为data1，当其他事务修改该数据为data2后，事务a再次读取时，发现为data2与前一次读取的不同。设置为“读提交”会出现该情况，为了避免不可重复读，设置隔离级别为“可重复读”或更高级别可以避免。
3. **幻读** 指在读取一批数据时，同一个事务在两次读取之间读取的数据数目不同。与不可重复读的区别在：不可重复读的重点在修改的某条数据值，幻读的重点在一批数据，针对数据量。

>下面的表格引用自[后盾人文档-隔离级别](http://houdunren.gitee.io/note/mysql/8%20%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86.html#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB)

<table><thead><tr><th>事务隔离级别</th> <th>脏读</th> <th>不可重复读</th> <th>幻读</th> <th>说明</th></tr></thead> <tbody><tr><td>读未提交（read-uncommitted）</td> <td>是</td> <td>是</td> <td>是</td> <td>最低的事务隔离级别，一个事务还没提交时，它做的变更就能被别的事务看到</td></tr> <tr><td>不可重复读（read-committed）</td> <td>否</td> <td>是</td> <td>是</td> <td>保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。</td></tr> <tr><td>可重复读（repeatable-read）</td> <td>否</td> <td>否</td> <td>是</td> <td>多次读取同一范围的数据会返回第一次查询的快照，即使其他事务对该数据做了更新修改。事务在执行期间看到的数据前后必须是一致的。</td></tr> <tr><td>串行化（serializable）</td> <td>否</td> <td>否</td> <td>否</td> <td>事务 100% 隔离，可避免脏读、不可重复读、幻读的发生。花费最高代价但最可靠的事务隔离级别。</td></tr></tbody></table>